{"ast":null,"code":"// A service for tracking user behavior and generating insights\nimport { getSocket } from './socket';\nimport { updateUserProfile } from './api';\nimport { analyzeTextForTopics, getAllTopics } from './topicDefinitions';\n// Initialize the storage for tracking behavioral data\nlet behaviorsToTrack = {\n  messageFrequency: [],\n  responseTime: [],\n  interactionPatterns: {},\n  activeHours: {},\n  friendPreferences: {},\n  topicInterests: {}\n};\n// Reset the tracking data\nconst resetTracking = () => {\n  behaviorsToTrack = {\n    messageFrequency: [],\n    responseTime: [],\n    interactionPatterns: {},\n    activeHours: {},\n    friendPreferences: {},\n    topicInterests: {}\n  };\n};\n// Track a message being sent\nconst trackMessageSent = (message, recipientId) => {\n  // Track timestamp for active hours analysis\n  const hour = new Date().getHours();\n  if (!behaviorsToTrack.activeHours[hour]) {\n    behaviorsToTrack.activeHours[hour] = 0;\n  }\n  behaviorsToTrack.activeHours[hour]++;\n  // Track friend interactions frequency\n  if (!behaviorsToTrack.friendPreferences[recipientId]) {\n    behaviorsToTrack.friendPreferences[recipientId] = {\n      messageCount: 0,\n      lastMessageTime: Date.now(),\n      totalResponseTime: 0,\n      responseCount: 0\n    };\n  }\n  behaviorsToTrack.friendPreferences[recipientId].messageCount++;\n  behaviorsToTrack.friendPreferences[recipientId].lastMessageTime = Date.now();\n  // Track message content for topic interests using centralized topic definitions\n  const messageText = message.content;\n  if (messageText) {\n    // Use the centralized topic analysis function\n    const matchedTopics = analyzeTextForTopics(messageText);\n    // Update topic interest counts\n    Object.keys(matchedTopics).forEach(topic => {\n      if (!behaviorsToTrack.topicInterests[topic]) {\n        behaviorsToTrack.topicInterests[topic] = 0;\n      }\n      behaviorsToTrack.topicInterests[topic]++;\n    });\n  }\n  // Save the updated tracking data after each interaction\n  saveTrackingData();\n  // For development purposes only - save to local JSON file\n  if (isDev) {\n    saveDevTrackingData('message_sent', {\n      message,\n      recipientId,\n      timestamp: new Date().toISOString()\n    });\n  }\n};\n// Track a message being received\nconst trackMessageReceived = (message, senderId) => {\n  var _behaviorsToTrack$fri;\n  // Calculate response time if it's a reply\n  if ((_behaviorsToTrack$fri = behaviorsToTrack.friendPreferences[senderId]) !== null && _behaviorsToTrack$fri !== void 0 && _behaviorsToTrack$fri.lastMessageTime) {\n    const responseTime = Date.now() - behaviorsToTrack.friendPreferences[senderId].lastMessageTime;\n    behaviorsToTrack.friendPreferences[senderId].totalResponseTime += responseTime;\n    behaviorsToTrack.friendPreferences[senderId].responseCount++;\n  }\n  // For development purposes only - save to local JSON file\n  if (isDev) {\n    var _behaviorsToTrack$fri2;\n    saveDevTrackingData('message_received', {\n      message,\n      senderId,\n      timestamp: new Date().toISOString(),\n      responseTime: (_behaviorsToTrack$fri2 = behaviorsToTrack.friendPreferences[senderId]) !== null && _behaviorsToTrack$fri2 !== void 0 && _behaviorsToTrack$fri2.lastMessageTime ? Date.now() - behaviorsToTrack.friendPreferences[senderId].lastMessageTime : null\n    });\n  }\n  // Track message content for topic interests using centralized topic definitions\n  const messageText = message.content;\n  if (messageText) {\n    // Use the centralized topic analysis function\n    const matchedTopics = analyzeTextForTopics(messageText);\n    // Update topic interest counts with half weight since it's not user-generated content\n    Object.keys(matchedTopics).forEach(topic => {\n      if (!behaviorsToTrack.topicInterests[topic]) {\n        behaviorsToTrack.topicInterests[topic] = 0;\n      }\n      behaviorsToTrack.topicInterests[topic] += 0.5;\n    });\n  }\n};\n// Save the tracking data to localStorage for persistence\nconst saveTrackingData = () => {\n  try {\n    localStorage.setItem('userBehaviorData', JSON.stringify(behaviorsToTrack));\n  } catch (error) {}\n};\n// Load the tracking data from localStorage\nconst loadTrackingData = () => {\n  try {\n    const savedData = localStorage.getItem('userBehaviorData');\n    if (savedData) {\n      behaviorsToTrack = JSON.parse(savedData);\n    }\n  } catch (error) {}\n};\n// Generate insights from collected behavioral data\nconst generateInsights = () => {\n  const insights = {\n    activeHours: getMostActiveHours(),\n    favoriteContacts: getFavoriteContacts(),\n    topicInterests: getTopTopics(),\n    communicationStyle: getCommunicationStyle()\n  };\n  return insights;\n};\n// Get the hours when the user is most active\nconst getMostActiveHours = () => {\n  const hours = Object.keys(behaviorsToTrack.activeHours).map(hour => ({\n    hour: parseInt(hour),\n    count: behaviorsToTrack.activeHours[hour]\n  })).sort((a, b) => b.count - a.count).slice(0, 3);\n  return hours.map(h => h.hour);\n};\n// Get the contacts the user interacts with most frequently\nconst getFavoriteContacts = () => {\n  return Object.keys(behaviorsToTrack.friendPreferences).map(friendId => ({\n    friendId,\n    messageCount: behaviorsToTrack.friendPreferences[friendId].messageCount\n  })).sort((a, b) => b.messageCount - a.messageCount).slice(0, 5).map(f => f.friendId);\n};\n// Get the topics the user discusses most frequently\nconst getTopTopics = () => {\n  return Object.keys(behaviorsToTrack.topicInterests).map(topic => ({\n    topic,\n    count: behaviorsToTrack.topicInterests[topic]\n  })).sort((a, b) => b.count - a.count).slice(0, 3).map(t => t.topic);\n};\n// Infer the user's communication style based on message patterns\nconst getCommunicationStyle = () => {\n  // Analyze average message length, response time, and message frequency\n  let totalMessages = 0;\n  let totalResponseTime = 0;\n  let responseCount = 0;\n  Object.values(behaviorsToTrack.friendPreferences).forEach(friend => {\n    totalMessages += friend.messageCount;\n    totalResponseTime += friend.totalResponseTime;\n    responseCount += friend.responseCount;\n  });\n  // Quick responder: average response time under 5 minutes\n  if (responseCount > 0 && totalResponseTime / responseCount < 5 * 60 * 1000) {\n    return 'Quick responder';\n  }\n  // Frequent communicator: more than 10 messages per friend on average\n  if (Object.keys(behaviorsToTrack.friendPreferences).length > 0 && totalMessages / Object.keys(behaviorsToTrack.friendPreferences).length > 10) {\n    return 'Frequent communicator';\n  }\n  // Default style\n  return 'Regular communicator';\n};\n// Sync insights with user profile periodically\nconst syncInsightsWithProfile = async userId => {\n  try {\n    // Only sync if we have enough data\n    if (Object.keys(behaviorsToTrack.activeHours).length === 0 && Object.keys(behaviorsToTrack.friendPreferences).length === 0) {\n      return;\n    }\n    const insights = generateInsights();\n    // Update the user profile with new insights\n    await updateUserProfile({\n      inferred: {\n        activeHours: insights.activeHours,\n        topicInterests: insights.topicInterests,\n        communicationStyle: insights.communicationStyle\n      }\n    });\n    // Track when we last synced insights\n    localStorage.setItem('lastInsightSync', Date.now().toString());\n  } catch (error) {}\n};\n// Initialize the behavior tracking\nconst initializeBehaviorTracking = userId => {\n  loadTrackingData();\n  // Setup periodic syncing (every week)\n  const checkAndSync = () => {\n    const lastSync = parseInt(localStorage.getItem('lastInsightSync') || '0');\n    const oneWeekMs = 7 * 24 * 60 * 60 * 1000;\n    if (Date.now() - lastSync > oneWeekMs) {\n      syncInsightsWithProfile(userId);\n    }\n  };\n  // Check if sync is needed when user opens app\n  checkAndSync();\n  // Also schedule regular checks\n  setInterval(checkAndSync, 24 * 60 * 60 * 1000); // Daily check\n  return {\n    trackMessageSent,\n    trackMessageReceived,\n    generateInsights,\n    resetTracking\n  };\n};\n// Development-only functions for local tracking\nconst loadDevTrackingData = () => {\n  if (!isDev || !fs) return null;\n  try {\n    const data = fs.readFileSync(DEV_TRACKING_PATH, 'utf8');\n    return JSON.parse(data);\n  } catch (error) {\n    // Return default structure if file doesn't exist or has issues\n    return {\n      users: {},\n      interactions: [],\n      messagePatterns: {},\n      responseTimeAnalysis: {},\n      conversationTopics: {},\n      sentiment: {},\n      userEngagement: {},\n      lastUpdated: new Date().toISOString()\n    };\n  }\n};\nconst saveDevTrackingData = (action, data) => {\n  if (!isDev) return;\n  // Function to analyze message content for topics using the centralized topic definitions\n  const analyzeMessageTopics = (message, currentData) => {\n    if (!message || !message.content) return;\n    // Ensure conversationTopics exists in the data structure\n    if (!currentData.conversationTopics) {\n      currentData.conversationTopics = {};\n    }\n    // Use our centralized topic analysis function\n    const matchedTopics = analyzeTextForTopics(message.content);\n    // Process each matched topic\n    Object.keys(matchedTopics).forEach(topic => {\n      // Initialize topic counter if not exists\n      if (!currentData.conversationTopics[topic]) {\n        currentData.conversationTopics[topic] = {\n          count: 0,\n          examples: [],\n          lastDetected: null\n        };\n      }\n      // Increment counter\n      currentData.conversationTopics[topic].count++;\n      // Add example (keep only up to 5 examples)\n      if (currentData.conversationTopics[topic].examples.length < 5) {\n        currentData.conversationTopics[topic].examples.push({\n          snippet: message.content.substring(0, 50) + (message.content.length > 50 ? '...' : ''),\n          timestamp: new Date().toISOString()\n        });\n      }\n      // Update last detected time\n      currentData.conversationTopics[topic].lastDetected = new Date().toISOString();\n    });\n    return currentData;\n  };\n  try {\n    // Use browser localStorage as fallback if fs is not available (for dev in browser)\n    if (!fs) {\n      const currentData = localStorage.getItem('devUserTracking') ? JSON.parse(localStorage.getItem('devUserTracking')) : devUserTracking;\n      // Update the interactions array\n      currentData.interactions.push({\n        action,\n        ...data,\n        timestamp: new Date().toISOString()\n      });\n      // Analyze for topics if it's a message\n      if ((action === 'message_sent' || action === 'message_received') && data.message) {\n        analyzeMessageTopics(data.message, currentData);\n      }\n      currentData.lastUpdated = new Date().toISOString();\n      // Save back to localStorage\n      localStorage.setItem('devUserTracking', JSON.stringify(currentData));\n      return;\n    }\n    // If fs is available, use the file system\n    const currentData = loadDevTrackingData() || devUserTracking;\n    // Update the interactions array\n    currentData.interactions.push({\n      action,\n      ...data,\n      timestamp: new Date().toISOString()\n    });\n    // Analyze for topics if it's a message\n    if ((action === 'message_sent' || action === 'message_received') && data.message) {\n      analyzeMessageTopics(data.message, currentData);\n    }\n    currentData.lastUpdated = new Date().toISOString();\n    // Save to file\n    fs.writeFileSync(DEV_TRACKING_PATH, JSON.stringify(currentData, null, 2));\n  } catch (error) {}\n};\nexport { initializeBehaviorTracking, trackMessageSent, trackMessageReceived, generateInsights, resetTracking,\n// Development only exports - not for production use\nloadDevTrackingData, saveDevTrackingData };","map":{"version":3,"names":["getSocket","updateUserProfile","analyzeTextForTopics","getAllTopics","behaviorsToTrack","messageFrequency","responseTime","interactionPatterns","activeHours","friendPreferences","topicInterests","resetTracking","trackMessageSent","message","recipientId","hour","Date","getHours","messageCount","lastMessageTime","now","totalResponseTime","responseCount","messageText","content","matchedTopics","Object","keys","forEach","topic","saveTrackingData","isDev","saveDevTrackingData","timestamp","toISOString","trackMessageReceived","senderId","_behaviorsToTrack$fri","_behaviorsToTrack$fri2","localStorage","setItem","JSON","stringify","error","loadTrackingData","savedData","getItem","parse","generateInsights","insights","getMostActiveHours","favoriteContacts","getFavoriteContacts","getTopTopics","communicationStyle","getCommunicationStyle","hours","map","parseInt","count","sort","a","b","slice","h","friendId","f","t","totalMessages","values","friend","length","syncInsightsWithProfile","userId","inferred","toString","initializeBehaviorTracking","checkAndSync","lastSync","oneWeekMs","setInterval","loadDevTrackingData","fs","data","readFileSync","DEV_TRACKING_PATH","users","interactions","messagePatterns","responseTimeAnalysis","conversationTopics","sentiment","userEngagement","lastUpdated","action","analyzeMessageTopics","currentData","examples","lastDetected","push","snippet","substring","devUserTracking","writeFileSync"],"sources":["C:/Users/sinha/Desktop/Computing Projects/INFS3059/friend-finder/client/src/services/behaviorTracking.js"],"sourcesContent":["// A service for tracking user behavior and generating insights\r\nimport { getSocket } from './socket';\r\nimport { updateUserProfile } from './api';\r\nimport { analyzeTextForTopics, getAllTopics } from './topicDefinitions';\r\n// Initialize the storage for tracking behavioral data\r\nlet behaviorsToTrack = {\r\n    messageFrequency: [],\r\n    responseTime: [],\r\n    interactionPatterns: {},\r\n    activeHours: {},\r\n    friendPreferences: {},\r\n    topicInterests: {}\r\n};\r\n// Reset the tracking data\r\nconst resetTracking = () => {\r\n    behaviorsToTrack = {\r\n        messageFrequency: [],\r\n        responseTime: [],\r\n        interactionPatterns: {},\r\n        activeHours: {},\r\n        friendPreferences: {},\r\n        topicInterests: {}\r\n    };\r\n};\r\n// Track a message being sent\r\nconst trackMessageSent = (message, recipientId) => {\r\n    // Track timestamp for active hours analysis\r\n    const hour = new Date().getHours();\r\n    if (!behaviorsToTrack.activeHours[hour]) {\r\n        behaviorsToTrack.activeHours[hour] = 0;\r\n    }\r\n    behaviorsToTrack.activeHours[hour]++;\r\n    // Track friend interactions frequency\r\n    if (!behaviorsToTrack.friendPreferences[recipientId]) {\r\n        behaviorsToTrack.friendPreferences[recipientId] = {\r\n            messageCount: 0,\r\n            lastMessageTime: Date.now(),\r\n            totalResponseTime: 0,\r\n            responseCount: 0\r\n        };\r\n    }\r\n    behaviorsToTrack.friendPreferences[recipientId].messageCount++;\r\n    behaviorsToTrack.friendPreferences[recipientId].lastMessageTime = Date.now();\r\n    // Track message content for topic interests using centralized topic definitions\r\n    const messageText = message.content;\r\n    if (messageText) {\r\n        // Use the centralized topic analysis function\r\n        const matchedTopics = analyzeTextForTopics(messageText);\r\n        // Update topic interest counts\r\n        Object.keys(matchedTopics).forEach(topic => {\r\n            if (!behaviorsToTrack.topicInterests[topic]) {\r\n                behaviorsToTrack.topicInterests[topic] = 0;\r\n            }\r\n            behaviorsToTrack.topicInterests[topic]++;\r\n        });\r\n    }\r\n    // Save the updated tracking data after each interaction\r\n    saveTrackingData();\r\n    // For development purposes only - save to local JSON file\r\n    if (isDev) {\r\n        saveDevTrackingData('message_sent', {\r\n            message, \r\n            recipientId, \r\n            timestamp: new Date().toISOString()\r\n        });\r\n    }\r\n};\r\n// Track a message being received\r\nconst trackMessageReceived = (message, senderId) => {\r\n    // Calculate response time if it's a reply\r\n    if (behaviorsToTrack.friendPreferences[senderId]?.lastMessageTime) {\r\n        const responseTime = Date.now() - behaviorsToTrack.friendPreferences[senderId].lastMessageTime;\r\n        behaviorsToTrack.friendPreferences[senderId].totalResponseTime += responseTime;\r\n        behaviorsToTrack.friendPreferences[senderId].responseCount++;\r\n    }\r\n    // For development purposes only - save to local JSON file\r\n    if (isDev) {\r\n        saveDevTrackingData('message_received', {\r\n            message,\r\n            senderId,\r\n            timestamp: new Date().toISOString(),\r\n            responseTime: behaviorsToTrack.friendPreferences[senderId]?.lastMessageTime ? \r\n                Date.now() - behaviorsToTrack.friendPreferences[senderId].lastMessageTime : null\r\n        });\r\n    }\r\n    // Track message content for topic interests using centralized topic definitions\r\n    const messageText = message.content;\r\n    if (messageText) {\r\n        // Use the centralized topic analysis function\r\n        const matchedTopics = analyzeTextForTopics(messageText);\r\n        // Update topic interest counts with half weight since it's not user-generated content\r\n        Object.keys(matchedTopics).forEach(topic => {\r\n            if (!behaviorsToTrack.topicInterests[topic]) {\r\n                behaviorsToTrack.topicInterests[topic] = 0;\r\n            }\r\n            behaviorsToTrack.topicInterests[topic] += 0.5;\r\n        });\r\n    }\r\n};\r\n// Save the tracking data to localStorage for persistence\r\nconst saveTrackingData = () => {\r\n    try {\r\n        localStorage.setItem('userBehaviorData', JSON.stringify(behaviorsToTrack));\r\n    } catch (error) {\r\n    }\r\n};\r\n// Load the tracking data from localStorage\r\nconst loadTrackingData = () => {\r\n    try {\r\n        const savedData = localStorage.getItem('userBehaviorData');\r\n        if (savedData) {\r\n            behaviorsToTrack = JSON.parse(savedData);\r\n        }\r\n    } catch (error) {\r\n    }\r\n};\r\n// Generate insights from collected behavioral data\r\nconst generateInsights = () => {\r\n    const insights = {\r\n        activeHours: getMostActiveHours(),\r\n        favoriteContacts: getFavoriteContacts(),\r\n        topicInterests: getTopTopics(),\r\n        communicationStyle: getCommunicationStyle()\r\n    };\r\n    return insights;\r\n};\r\n// Get the hours when the user is most active\r\nconst getMostActiveHours = () => {\r\n    const hours = Object.keys(behaviorsToTrack.activeHours)\r\n        .map(hour => ({\r\n            hour: parseInt(hour),\r\n            count: behaviorsToTrack.activeHours[hour]\r\n        }))\r\n        .sort((a, b) => b.count - a.count)\r\n        .slice(0, 3);\r\n    return hours.map(h => h.hour);\r\n};\r\n// Get the contacts the user interacts with most frequently\r\nconst getFavoriteContacts = () => {\r\n    return Object.keys(behaviorsToTrack.friendPreferences)\r\n        .map(friendId => ({\r\n            friendId,\r\n            messageCount: behaviorsToTrack.friendPreferences[friendId].messageCount\r\n        }))\r\n        .sort((a, b) => b.messageCount - a.messageCount)\r\n        .slice(0, 5)\r\n        .map(f => f.friendId);\r\n};\r\n// Get the topics the user discusses most frequently\r\nconst getTopTopics = () => {\r\n    return Object.keys(behaviorsToTrack.topicInterests)\r\n        .map(topic => ({\r\n            topic,\r\n            count: behaviorsToTrack.topicInterests[topic]\r\n        }))\r\n        .sort((a, b) => b.count - a.count)\r\n        .slice(0, 3)\r\n        .map(t => t.topic);\r\n};\r\n// Infer the user's communication style based on message patterns\r\nconst getCommunicationStyle = () => {\r\n    // Analyze average message length, response time, and message frequency\r\n    let totalMessages = 0;\r\n    let totalResponseTime = 0;\r\n    let responseCount = 0;\r\n    Object.values(behaviorsToTrack.friendPreferences).forEach(friend => {\r\n        totalMessages += friend.messageCount;\r\n        totalResponseTime += friend.totalResponseTime;\r\n        responseCount += friend.responseCount;\r\n    });\r\n    // Quick responder: average response time under 5 minutes\r\n    if (responseCount > 0 && (totalResponseTime / responseCount) < 5 * 60 * 1000) {\r\n        return 'Quick responder';\r\n    }\r\n    // Frequent communicator: more than 10 messages per friend on average\r\n    if (Object.keys(behaviorsToTrack.friendPreferences).length > 0 && \r\n        (totalMessages / Object.keys(behaviorsToTrack.friendPreferences).length) > 10) {\r\n        return 'Frequent communicator';\r\n    }\r\n    // Default style\r\n    return 'Regular communicator';\r\n};\r\n// Sync insights with user profile periodically\r\nconst syncInsightsWithProfile = async (userId) => {\r\n    try {\r\n        // Only sync if we have enough data\r\n        if (Object.keys(behaviorsToTrack.activeHours).length === 0 && \r\n            Object.keys(behaviorsToTrack.friendPreferences).length === 0) {\r\n            return;\r\n        }\r\n        const insights = generateInsights();\r\n        // Update the user profile with new insights\r\n        await updateUserProfile({\r\n            inferred: {\r\n                activeHours: insights.activeHours,\r\n                topicInterests: insights.topicInterests,\r\n                communicationStyle: insights.communicationStyle\r\n            }\r\n        });\r\n        // Track when we last synced insights\r\n        localStorage.setItem('lastInsightSync', Date.now().toString());\r\n    } catch (error) {\r\n    }\r\n};\r\n// Initialize the behavior tracking\r\nconst initializeBehaviorTracking = (userId) => {\r\n    loadTrackingData();\r\n    // Setup periodic syncing (every week)\r\n    const checkAndSync = () => {\r\n        const lastSync = parseInt(localStorage.getItem('lastInsightSync') || '0');\r\n        const oneWeekMs = 7 * 24 * 60 * 60 * 1000;\r\n        if (Date.now() - lastSync > oneWeekMs) {\r\n            syncInsightsWithProfile(userId);\r\n        }\r\n    };\r\n    // Check if sync is needed when user opens app\r\n    checkAndSync();\r\n    // Also schedule regular checks\r\n    setInterval(checkAndSync, 24 * 60 * 60 * 1000); // Daily check\r\n    return {\r\n        trackMessageSent,\r\n        trackMessageReceived,\r\n        generateInsights,\r\n        resetTracking\r\n    };\r\n};\r\n// Development-only functions for local tracking\r\nconst loadDevTrackingData = () => {\r\n    if (!isDev || !fs) return null;\r\n    try {\r\n        const data = fs.readFileSync(DEV_TRACKING_PATH, 'utf8');\r\n        return JSON.parse(data);\r\n    } catch (error) {\r\n        // Return default structure if file doesn't exist or has issues\r\n        return {\r\n            users: {},\r\n            interactions: [],\r\n            messagePatterns: {},\r\n            responseTimeAnalysis: {},\r\n            conversationTopics: {},\r\n            sentiment: {},\r\n            userEngagement: {},\r\n            lastUpdated: new Date().toISOString()\r\n        };\r\n    }\r\n};\r\nconst saveDevTrackingData = (action, data) => {\r\n    if (!isDev) return;\r\n    // Function to analyze message content for topics using the centralized topic definitions\r\n    const analyzeMessageTopics = (message, currentData) => {\r\n        if (!message || !message.content) return;\r\n        // Ensure conversationTopics exists in the data structure\r\n        if (!currentData.conversationTopics) {\r\n            currentData.conversationTopics = {};\r\n        }\r\n        // Use our centralized topic analysis function\r\n        const matchedTopics = analyzeTextForTopics(message.content);\r\n        // Process each matched topic\r\n        Object.keys(matchedTopics).forEach(topic => {\r\n            // Initialize topic counter if not exists\r\n            if (!currentData.conversationTopics[topic]) {\r\n                currentData.conversationTopics[topic] = { \r\n                    count: 0,\r\n                    examples: [],\r\n                    lastDetected: null\r\n                };\r\n            }\r\n            // Increment counter\r\n            currentData.conversationTopics[topic].count++;\r\n            // Add example (keep only up to 5 examples)\r\n            if (currentData.conversationTopics[topic].examples.length < 5) {\r\n                currentData.conversationTopics[topic].examples.push({\r\n                    snippet: message.content.substring(0, 50) + (message.content.length > 50 ? '...' : ''),\r\n                    timestamp: new Date().toISOString()\r\n                });\r\n            }\r\n            // Update last detected time\r\n            currentData.conversationTopics[topic].lastDetected = new Date().toISOString();\r\n        });\r\n        return currentData;\r\n    };\r\n    try {\r\n        // Use browser localStorage as fallback if fs is not available (for dev in browser)\r\n        if (!fs) {\r\n            const currentData = localStorage.getItem('devUserTracking') \r\n                ? JSON.parse(localStorage.getItem('devUserTracking')) \r\n                : devUserTracking;\r\n            // Update the interactions array\r\n            currentData.interactions.push({ action, ...data, timestamp: new Date().toISOString() });\r\n            // Analyze for topics if it's a message\r\n            if ((action === 'message_sent' || action === 'message_received') && data.message) {\r\n                analyzeMessageTopics(data.message, currentData);\r\n            }\r\n            currentData.lastUpdated = new Date().toISOString();\r\n            // Save back to localStorage\r\n            localStorage.setItem('devUserTracking', JSON.stringify(currentData));\r\n            return;\r\n        }\r\n        // If fs is available, use the file system\r\n        const currentData = loadDevTrackingData() || devUserTracking;\r\n        // Update the interactions array\r\n        currentData.interactions.push({ action, ...data, timestamp: new Date().toISOString() });\r\n        // Analyze for topics if it's a message\r\n        if ((action === 'message_sent' || action === 'message_received') && data.message) {\r\n            analyzeMessageTopics(data.message, currentData);\r\n        }\r\n        currentData.lastUpdated = new Date().toISOString();\r\n        // Save to file\r\n        fs.writeFileSync(DEV_TRACKING_PATH, JSON.stringify(currentData, null, 2));\r\n    } catch (error) {\r\n    }\r\n};\r\nexport { \r\n    initializeBehaviorTracking,\r\n    trackMessageSent,\r\n    trackMessageReceived,\r\n    generateInsights,\r\n    resetTracking,\r\n    // Development only exports - not for production use\r\n    loadDevTrackingData,\r\n    saveDevTrackingData\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}